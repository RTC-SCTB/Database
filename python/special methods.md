Специальные методы - одна из основных фич питона.
Заставляют ваши классы работать подобно встроенных классов,
а также делают много чего полезного.

Тут будут описаны основные и наиболее полезные методы

## Инициализация/окончание работы
* \_\_init\_\_(self, *args)
```python
class Test:
    def __init__(self, *args):
        pass
        
Test(1, 2, 3)
```
Метод - инициализатор класса, принимает аргументы, при котором будет вызван  
конструктор класса.

* \_\_new\_\_(cls, *args)
```python
class Test:
    def __new__(cls, *args):
        pass
```
Метод - инициализатор, который вызывается самым первым до \_\_init\_\_
принимает в качестве аргумента класс и аргументы, которые будут переданы в 
\_\_init\_\_. Используется редко, в основном полезен при наследовании от неизменяемых
классов(+ при наследовании от numpy.ndarray)

* \_\_del\_\_(self)
Деструктор, вызывается при окончании работы интерпритатора, когда
запускается сборщик мусора. Полезен для дополнительной чистки программы - 
закрытие портов, файлов и т.д.

## Приведение типов
Приводят типы к встроенным типам int, float, double и т.д.
Полезны, иногда работают неявно:
```python
if object:
    pass
```
Для Проверки истинности вызовется приведение к bool.

```python
class Gpio:
    def __init__(self):
        self._pin = 1
        
    def __int__(self):
        return self._pin

gpio = Gpio()
pin = int(gpio)
```

* \_\_int\_\_(self)
Преобразование типа в int.

* \_\_long\_\_(self)
Преобразование типа в long.

* \_\_float\_\_(self)
Преобразование типа в float.

* \_\_complex\_\_(self)
Преобразование типа в комплексное число.

* \_\_oct\_\_(self)
Преобразование типа в восьмеричное число.

* \_\_hex\_\_(self)
Преобразование типа в шестнадцатиричное число.

* \_\_index\_\_(self)
Преобразование типа к int, когда объект используется в срезах (выражения вида \[start:stop:step\]). Если вы определяете
свой числовый тип, который может использоваться как индекс списка, вы должны определить \_\_index\_\_.

## Контроль доступа к аттрибутам
Тут находятся одни из самых важных специальных методов.

* \_\_setattr\_\_(self, name, value)
Это один из мощных методов, который при неправильном использовании сломает ваше приложение, психику и, возможно, жизнь.
Его первоначальная задача - создать в классе self аттрибут с именем name и значением value или изменить аттрибут
с таким же именем:
```python
class Past:
    def __init__(self):
        pass

past = Past()
past.lol = 2  # равноценно вызову past.__setattr__("lol", 2)
print(past.lol)     # будет выведено 2
```
В чем особенности:
* Можно запрещать присваивать все аттрибуты:
```python
class Enum:
    first = 1
    second = 2
        
    def __setattr__(self, key, value):
        raise AttributeError("Нельзя менять значения")
        
enum = Enum()
enum.first = 2  # вызовется исключение
```
*НО)))* Вот так сделать не получится:
```python
class SomeData:
    def __init__(self):
        self.data = 1   # тут вызовется исключение, т.к. вызовется self.__setattr__("data", 1) :)
        
    def __setattr__(self, key, value):
        raise AttributeError("Нельзя менять значения")

data = SomeData()
```

* А еще он может подгадить так:
```python
class Test:
    def __init__(self):
        self.data = 1   # тут класс войдет в рекурсию) и при привышении стека вызовов вызовется исключение
    
    def __setattr__(self, key, value):
        if key == "data":
            self.data = value

Test()
```
Решением этого является:
```python
class Test:
    def __init__(self):
        self.data = 1
        self.otherData = 2
    
    def __setattr__(self, key, value):
        self.__dict__[key] = value  # добавляем/изменяем значение одного из полей класса без вызова __setattr__

test = Test()
print(test.__dict__)    # выведется {'data': 1, 'someData': 2} 
```

Казалось бы, зачем он вообще тогда нужен, и лучше бы его не трогать, и это разумно)
* Приватные переменные
```python
class Private:
    def __init__(self):
        self.__privateVar = 22  # В памяти класса эта переменная будет храниться как _Private__privateVar 
        
private = Private()
private.__privateVar = 1    # Т.к. переменная __privateVar была создана с другим именем, имя __privateVar свободно,
#  и оно занимается данным значением
```

Одно из решений, сделанных в библиотеке vispy:  
![Frozen](https://github.com/RTC-SCTB/Database/blob/master/python/Images/Frozen.png)         
Классы наследуются от Frozen и после вызова freeze нельзя добавить новых аттрибутов, также при наследовании от классов
наследников Frozen, после их инициализации также нельзя добавлять новых аттрибутов.

Данный метод - один из ключевых специальных методов класса, который может сделать питон более похожим на стандартное ООП

## Представление классов
```python
class Test:
    def __init__(self):
        self._data = 10
    
    def __repr__(self):
        return "<Class Test: data=" + self._data + ">"
        
test = Test()
print(test)     # напечатает <Class Test: data=10>
```

* \_\_str\_\_(self)
Определяет поведение функции str(), вызванной для экземпляра вашего класса.

* \_\_repr\_\_(self)
Определяет поведение функции repr(), вызыванной для экземпляра вашего класса. Главное отличие от str() в целевой
аудитории. repr() больше предназначен для машинно-ориентированного вывода (более того, это часто должен быть валидный
код на Питоне), а str() предназначен для чтения людьми.

* \_\_format\_\_(self, formatstr)
Определяет поведение, когда экземпляр вашего класса используется в форматировании строк. Например,
"Hello, {0:abc}!".format(a) приведёт к вызову a.\_\_format\_\_("abc"). Это может быть полезно для определения ваших
собственных числовых или строковых типов, которым вы можете захотеть предоставить какие-нибудь специальные опции
форматирования.

* \_\_hash\_\_(self)
Определяет поведение функции hash(), вызыванной для экземпляра вашего класса. Метод должен возвращать целочисленное
значение, которое будет использоваться для быстрого сравнения ключей в словарях. Заметьте, что в таком случае обычно
нужно определять и \_\_eq\_\_ тоже. Руководствуйтесь следующим правилом: a == b подразумевает hash(a) == hash(b).

* \_\_sizeof\_\_(self)
Определяет поведение функции sys.getsizeof(), вызыванной на экземпляре вашего класса. Метод должен вернуть размер
вашего объекта в байтах. Он главным образом полезен для классов, определённых в расширениях на C, но всё-равно
полезно о нём знать.

## Сравнение/Арифметические операторы и т.д.
### Дальнейшие операторы, могут внести не понятный интуитивно смысл и использовать их нужно очень осторожно
### Их можно и иногда нужно неиспользовать
* \_\_cmp\_\_(self, other)
Самый базовый из методов сравнения. Он, в действительности, определяет поведение для всех операторов
сравнения (>, ==, !=, итд.), но не всегда так, как вам это нужно (например, если эквивалентность двух
экземпляров определяется по одному критерию, а то что один больше другого по какому-нибудь другому).
\_\_cmp\_\_ должен вернуть отрицательное число, если self < other, ноль, если self == other, и положительное
число в случае self > other. Но, обычно, лучше определить каждое сравнение, которое вам нужно, чем определять их
всех в \_\_cmp\_\_. Но \_\_cmp\_\_ может быть хорошим способом избежать повторений и увеличить ясность, когда все необходимые
сравнения оперерируют одним критерием.

* \_\_eq\_\_(self, other)
Определяет поведение оператора равенства, ==

* \_\_ne\_\_(self, other)
Определяет поведение оператора неравенства, !=

* \_\_lt\_\_(self, other)
Определяет поведение оператора меньше, <

* \_\_gt\_\_(self, other)
Определяет поведение оператора больше, >

* \_\_le\_\_(self, other)
Определяет поведение оператора меньше или равно, <=

* \_\_ge\_\_(self, other)
Определяет поведение оператора больше или равно, >=

* \_\_pos\_\_(self)
Определяет поведение для унарного плюса (+some_object)

* \_\_neg\_\_(self)
Определяет поведение для отрицания(-some_object)

* \_\_abs\_\_(self)
Определяет поведение для встроенной функции abs()

* \_\_invert\_\_(self)
Определяет поведение для инвертирования оператором ~ 

* \_\_round\_\_(self, n)
Определяет поведение для встроенной функции round().
n это число знаков после запятой, до которого округлить.

* \_\_floor\_\_(self)
Определяет поведение для math.floor(), 
то есть, округления до ближайшего меньшего целого.

* \_\_ceil\_\_(self)
Определяет поведение для math.ceil(), то есть,
округления до ближайшего большего целого.

* \_\_trunc\_\_(self)
Определяет поведение для math.trunc(), то есть, обрезания до целого.

* \_\_add\_\_(self, other)
Сложение

* \_\_sub\_\_(self, other)
Вычитание

* \_\_mul\_\_(self, other)
Умножение

* \_\_floordiv\_\_(self, other)
Целочисленное деление, оператор

* \_\_div\_\_(self, other)
Деление, оператор /

* \_\_mod\_\_(self, other)
Остаток от деления, оператор %

* \_\_divmod\_\_(self, other)
Определяет поведение для встроенной функции divmod()

* \_\_pow\_\_
Возведение в степень, оператор **

* \_\_lshift\_\_(self, other)
Двоичный сдвиг влево, оператор <<

* \_\_rshift\_\_(self, other)
Двоичный сдвиг вправо, оператор >>

* \_\_and\_\_(self, other)
Двоичное И, оператор &

* \_\_or\_\_(self, other)
Двоичное ИЛИ, оператор |

* \_\_xor\_\_(self, other)
Двоичный xor, оператор ^

** Еще есть отраженные операторы, составные операторы и т.д.**





